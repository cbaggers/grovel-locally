(in-package #:grovel-cache)

(defun read-wrapper-spec (input-file)
 (with-cached-reader-conditionals
    (with-open-file (in input-file :direction :input)
      (loop :for form = (read in nil nil) :while form :collect form))))

(defun generate-c-lib-file (input-data c-file)
  (let ((cffi-grovel::*lisp-forms* nil))
    (ensure-directory-pathname (pathname-directory-pathname c-file))
    (with-open-file (cffi-grovel::out c-file :direction :output
                        :if-exists :supersede)
      (cffi-grovel::write-string cffi-grovel::*header* cffi-grovel::out)
      (loop :for form :in input-data
         :do (cffi-grovel::process-wrapper-form cffi-grovel::out form)))
     (values c-file (nreverse cffi-grovel::*lisp-forms*))))


;; {TODO} It should be possible to reduce this down to working out the cache dir
;;        and passing it to #'generate-bindings-file as the lib-file
(defun generate-bindings-file* (lib-file lib-soname lisp-forms output-defaults
                                system cached-lib)
  (with-standard-io-syntax
    (let ((lisp-file (cffi-grovel::tmp-lisp-file-name output-defaults))
          (*print-readably* nil)
          (*print-escape* t))
      (with-open-file (out lisp-file :direction :output :if-exists :supersede)
        (format out ";;;; This file was automatically generated by cffi-grovel.~%~
                   ;;;; Do not edit by hand.~%")
        (let ((*package* (find-package '#:cl))
              (named-library-name
               (let ((*package* (find-package :keyword))
                     (*read-eval* nil))
                 (read-from-string lib-soname)))
              (search-file (if cached-lib
                               `(system-relative-pathname
                                 ,(component-name system)
                                 ,(pathname-directory-pathname cached-lib))
                               (directory-namestring lib-file))))
          (pprint `(progn
                     (cffi:define-foreign-library
                         (,named-library-name
                          :type :grovel-wrapper
                          :search-path ,search-file)
                       (t ,(namestring
                            (cffi-grovel::make-lib-file-name lib-soname))))
                     (cffi:use-foreign-library ,named-library-name))
                  out)
          (fresh-line out))
        (dolist (form lisp-forms)
          (print form out))
        (terpri out))
      lisp-file)))


(defun process-wrapper-file* (system input-file dest-lisp-file dest-lib-file
                              c-file o-file &key lib-soname cache-dir)
   (with-standard-io-syntax
    (multiple-value-bind (input-data feature-expressions)
        (read-wrapper-spec input-file)
      (let* ((cached-lib-file (feature-specific-cache-file
                               dest-lib-file cache-dir feature-expressions))
             (cached-lisp-file (feature-specific-cache-file
                                dest-lisp-file cache-dir feature-expressions))
             (*local-includes* nil))
        (if (process-from-cache-p system cached-lisp-file cached-lib-file)
            (process-wrapper-file-from-cache system dest-lib-file dest-lisp-file
                                             c-file o-file
                                             cached-lib-file cached-lisp-file)
            (process-wrapper-file-from-scratch system input-data dest-lisp-file
                                               lib-soname dest-lib-file c-file
                                               o-file cached-lib-file
                                               cached-lisp-file))
        (values dest-lisp-file dest-lib-file)))))

(defun process-wrapper-file-from-cache (system dest-lib-file dest-lisp-file
                                        c-file o-file
                                        cached-lib-file cached-lisp-file)
  ;;
  ;; We don't cache these but asdf is expecting them so make sure they exist
  (touch-file c-file)
  (touch-file o-file)

  ;; We need the delete-file-if-exists as if we dont have it then running
  ;; (asdf:load-system :osicat :force t :verbose nil) twice causes a memory
  ;; fault.
  ;; I expect some OS level shenanigans I don't understand yet - [Baggers]
  (delete-file-if-exists dest-lib-file)
  (let ((cached-lisp-file (system-relative-pathname system cached-lisp-file))
        (cached-lib-file (system-relative-pathname system cached-lib-file)))
    (alexandria:copy-file cached-lisp-file dest-lisp-file
                          :if-to-exists :supersede)
    (alexandria:copy-file cached-lib-file dest-lib-file
                          :if-to-exists :supersede)))

(defun process-wrapper-file-from-scratch (system input-data dest-lisp-file
                                          lib-soname lib-file c-file o-file
                                          cached-lib-file cached-lisp-file)
  ;;
  (multiple-value-bind (c-file lisp-forms)
      (generate-c-lib-file input-data c-file)
    (let ((inputs (list (cffi-grovel::cc-include-grovel-argument) c-file)))
      (when *local-includes*
        (push (copy-local-includes-to-cache c-file) inputs))
      (cffi-grovel::cc-compile o-file inputs))
    (cffi-grovel::link-shared-library lib-file (list o-file))
    (let ((tmp-file (generate-bindings-file* lib-file lib-soname lisp-forms
                                             dest-lisp-file system
                                             cached-lib-file)))
      (unwind-protect (alexandria:copy-file tmp-file dest-lisp-file
                                            :if-to-exists :supersede)
        (delete-file tmp-file))
      (when (and cached-lisp-file cached-lib-file)
        (let ((cached-lisp-file (system-relative-pathname system cached-lisp-file))
              (cached-lib-file (system-relative-pathname system cached-lib-file)))
          (ensure-directories-exist
           (pathname-directory-pathname cached-lib-file))
          (alexandria:copy-file dest-lisp-file cached-lisp-file
                                :if-to-exists :supersede)
          (alexandria:copy-file lib-file cached-lib-file
                                :if-to-exists :supersede))))))

;;------------------------------------------------------------

(defun process-from-cache-p (system cached-lisp-file cached-lib-file)
  (and cached-lib-file
       cached-lisp-file
       (uiop:file-exists-p (system-relative-pathname system cached-lib-file))
       (uiop:file-exists-p (system-relative-pathname system cached-lisp-file))))
