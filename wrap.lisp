(in-package #:grovel-cache)

(defun read-wrapper-spec (input-file)
 (with-open-file (in input-file :direction :input)
   (loop :for form = (read in nil nil) :while form :collect form)))

(defun generate-c-lib-file (input-data c-file)
  (let ((cffi-grovel::*lisp-forms* nil))
    (ensure-directory-pathname (pathname-directory-pathname c-file))
    (with-open-file (cffi-grovel::out c-file :direction :output
                        :if-exists :supersede)
      (cffi-grovel::write-string cffi-grovel::*header* cffi-grovel::out)
      (loop :for form :in input-data
         :do (cffi-grovel::process-wrapper-form cffi-grovel::out form)))
     (values c-file (nreverse cffi-grovel::*lisp-forms*))))

(defun generate-bindings-file* (lib-file lib-soname lisp-forms output-defaults
                                system)
  (with-standard-io-syntax
    (let ((lisp-file (cffi-grovel::tmp-lisp-file-name output-defaults))
          (*print-readably* nil)
          (*print-escape* t))
      (with-open-file (out lisp-file :direction :output :if-exists :supersede)
        (format out ";;;; This file was automatically generated by cffi-grovel.~%~
                   ;;;; Do not edit by hand.~%")
        (let ((*package* (find-package '#:cl))
              (named-library-name
               (let ((*package* (find-package :keyword))
                     (*read-eval* nil))
                 (read-from-string lib-soname)))
              (search-file `(system-relative-pathname
                             ,(component-name system)
                             ,(pathname-directory-pathname lib-file))))
          (pprint `(progn
                     (cffi:define-foreign-library
                         (,named-library-name
                          :type :grovel-wrapper
                          :search-path ,search-file)
                       (t ,(namestring
                            (cffi-grovel::make-lib-file-name lib-soname))))
                     (cffi:use-foreign-library ,named-library-name))
                  out)
          (fresh-line out))
        (dolist (form lisp-forms)
          (print form out))
        (terpri out))
      lisp-file)))


(defun process-wrapper-file* (system spec-file dest-lisp-file dest-lib-file
                              c-file o-file &key lib-soname)
   (with-standard-io-syntax
    (multiple-value-bind (input-data) (read-wrapper-spec spec-file)
      (let* ((*local-includes* nil))
        (unless (process-from-cache-p system dest-lisp-file dest-lib-file)
          (process-wrapper-file-from-scratch system input-data dest-lisp-file
                                             lib-soname dest-lib-file c-file
                                             o-file))
        (values dest-lisp-file dest-lib-file)))))

(defun process-wrapper-file-from-scratch (system input-data dest-lisp-file
                                          lib-soname lib-file c-file o-file)
  ;;
  (multiple-value-bind (c-file lisp-forms)
      (generate-c-lib-file input-data c-file)
    (let ((inputs (list (cffi-grovel::cc-include-grovel-argument) c-file)))
      (when *local-includes*
        (push (copy-local-includes-to-cache c-file) inputs))
      (cffi-grovel::cc-compile o-file inputs))
    (cffi-grovel::link-shared-library lib-file (list o-file))
    (let ((tmp-file (generate-bindings-file* lib-file lib-soname lisp-forms
                                             dest-lisp-file system)))
      (unwind-protect (alexandria:copy-file tmp-file dest-lisp-file
                                            :if-to-exists :supersede)
        (delete-file tmp-file))
      nil)))

;;------------------------------------------------------------

(defun process-from-cache-p (system cached-lisp-file cached-lib-file)
  (and cached-lib-file
       cached-lisp-file
       (uiop:file-exists-p (system-relative-pathname system cached-lib-file))
       (uiop:file-exists-p (system-relative-pathname system cached-lisp-file))))
